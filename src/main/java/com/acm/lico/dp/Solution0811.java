package com.acm.lico.dp;

/**
 硬币:面试题 08.11
 2023-10-20 16:12:54
 //硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)
 //
 // 示例1:
 //
 //
 // 输入: n = 5
 // 输出：2
 // 解释: 有两种方式可以凑成总金额:
 //5=5
 //5=1+1+1+1+1
 //
 //
 // 示例2:
 //
 //
 // 输入: n = 10
 // 输出：4
 // 解释: 有四种方式可以凑成总金额:
 //10=10
 //10=5+5
 //10=5+1+1+1+1+1
 //10=1+1+1+1+1+1+1+1+1+1
 //
 //
 // 说明：
 //
 // 注意:
 //
 // 你可以假设：
 //
 //
 // 0 <= n (总金额) <= 1000000
 //
 //
 // Related Topics 数组 数学 动态规划 👍 281 👎 0

 **/

//leetcode submit region begin(Prohibit modification and deletion)
class Solution0811 {
    /**
     1 复杂度分析
     估算问题中复杂度的上限和下限
     时间复杂度
     空间复杂度
     O(1) 一个常量下完成
     O(n) 一次遍历
     O(logn) 折半查询
     O(n^2) 两重嵌套循环查询
     2 定位问题
     根据问题类型，确定采用何种算法思维。
     例如
     这个问题是什么类型（排序、查找、最优化）的问题；
     这个问题的复杂度下限是多少，即最低的时间复杂度可能是多少；
     采用哪些数据结构或算法思维，能把这个问题解决。
     思路： 动态规划， dp[i][j] 表示 使用 i 种面币值，组成值为j 的最大方法。
     1. dp[i][j] = dp[i-1][j](不适用面币为i的最大方法) + dp[i][j-cos[i]](使用面币 值为i的) 的最大方法。

     3 数据操作分析
     根据增、删、查和数据顺序关系去选择合适的数据结构，利用空间换取时间。
     4 编码实现
     5 执行结果
     解答成功:
     执行耗时:28 ms,击败了32.00% 的Java用户
     内存消耗:67.4 MB,击败了18.66% 的Java用户
     */
    public int waysToChangeNew20(int n) {
        int[] coins = new int[]{1, 5, 10, 25};
        int[][] dp = new int[5][n +1];
        // 不选 组成 0面币值 都是一种
        for(int i = 1; i <= coins.length; i ++) {
            dp[i][0] = 1;
        }
        int max = 1000000007;
        for(int i = 1; i <= coins.length; i ++ ) {
            for(int j = 1; j <= n; j ++) {
                if(j - coins[i-1] < 0) {
                    dp[i][j] =dp[i-1][j] % max;
                } else {
                    dp[i][j] = (dp[i][j-coins[i-1]] + dp[i-1][j]) % max ;
                }
            }
        }
        return dp[4][n];
    }


    /**
     1 复杂度分析
     估算问题中复杂度的上限和下限
     时间复杂度
     空间复杂度
     O(1) 一个常量下完成
     O(n) 一次遍历
     O(logn) 折半查询
     O(n^2) 两重嵌套循环查询
     2 定位问题
     根据问题类型，确定采用何种算法思维。
     例如
     这个问题是什么类型（排序、查找、最优化）的问题；
     这个问题的复杂度下限是多少，即最低的时间复杂度可能是多少；
     采用哪些数据结构或算法思维，能把这个问题解决。
     思路： 动态规划， dp[i][j] 表示 使用 i 种面币值，组成值为j 的最大方法。
     1. dp[i][j] = dp[i-1][j](不适用面币为i的最大方法) + dp[i][j-cos[i]](使用面币 值为i的) 的最大方法。
     2. 因为 dp[i][j] 只跟 dp[i-1][j] 有关系。 所有改成一维 dp[i] 表示 面值 为i 的最大方法
     3. dp[i] = dp[i] + dp[i - cos[j]]
     3 数据操作分析
     根据增、删、查和数据顺序关系去选择合适的数据结构，利用空间换取时间。
     4 编码实现
     5 执行结果
     解答成功:
     执行耗时:25 ms,击败了40.80% 的Java用户
     内存消耗:41.3 MB,击败了55.47% 的Java用户
     */
    public int waysToChange(int n) {
        int[] coins = new int[]{1, 5, 10, 25};
        int[] dp = new int[n +1];
        // 不选 组成 0面币值 都是一种
        dp[0] = 1;
        int max = 1000000007;
        for(int i = 0; i < coins.length; i ++ ) {
            for(int j = 1; j <= n; j ++) {
                if(j - coins[i] >= 0) {
                    dp[j] = (dp[j] + dp[j - coins[i]]) % max;
                }
            }
        }
        return dp[n];
    }
}
//leetcode submit region end(Prohibit modification and deletion)
